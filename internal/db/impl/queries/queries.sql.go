// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
)

const actorIdByInbox = `-- name: ActorIdByInbox :one
SELECT ap_id FROM users u WHERE u.inbox = ?1
UNION
SELECT url AS ap_id FROM collectives i WHERE i.inbox = ?1
`

func (q *Queries) ActorIdByInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, actorIdByInbox, inbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const actorIdByOutbox = `-- name: ActorIdByOutbox :one
SELECT ap_id from users u where u.outbox = ?1
UNION
SELECT url as ap_id FROM collectives i WHERE i.outbox = ?1
`

func (q *Queries) ActorIdByOutbox(ctx context.Context, outbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, actorIdByOutbox, outbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const addToCollection = `-- name: AddToCollection :one
INSERT INTO ap_collection_members (collection_ap_id, member_ap_id) VALUES (?, ?) RETURNING id
`

type AddToCollectionParams struct {
	CollectionApID string
	MemberApID     string
}

func (q *Queries) AddToCollection(ctx context.Context, arg AddToCollectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addToCollection, arg.CollectionApID, arg.MemberApID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const apExists = `-- name: ApExists :one
SELECT EXISTS(SELECT TRUE FROM ap_object_cache WHERE ap_id = ?)
`

func (q *Queries) ApExists(ctx context.Context, apID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, apExists, apID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const authUserByEmail = `-- name: AuthUserByEmail :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND a.email = ?1
LIMIT 1
`

type AuthUserByEmailRow struct {
	UserID    int64
	AccountID int64
	Username  sql.NullString
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByEmail(ctx context.Context, email string) (AuthUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByEmail, email)
	var i AuthUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const authUserByUsername = `-- name: AuthUserByUsername :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND u.username = ?1
LIMIT 1
`

type AuthUserByUsernameRow struct {
	UserID    int64
	AccountID int64
	Username  sql.NullString
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByUsername(ctx context.Context, username sql.NullString) (AuthUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByUsername, username)
	var i AuthUserByUsernameRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const collectionContains = `-- name: CollectionContains :one
SELECT EXISTS(SELECT TRUE FROM ap_collection_members WHERE collection_ap_id = ? AND member_ap_id = ?)
`

type CollectionContainsParams struct {
	CollectionApID string
	MemberApID     string
}

func (q *Queries) CollectionContains(ctx context.Context, arg CollectionContainsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, collectionContains, arg.CollectionApID, arg.MemberApID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const collectionMembersIRIs = `-- name: CollectionMembersIRIs :many
SELECT member_ap_id FROM ap_collection_members WHERE collection_ap_id = ?
`

func (q *Queries) CollectionMembersIRIs(ctx context.Context, collectionApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, collectionMembersIRIs, collectionApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var member_ap_id string
		if err := rows.Scan(&member_ap_id); err != nil {
			return nil, err
		}
		items = append(items, member_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO 
    accounts (password, admin, email, user_id)
VALUES 
    (?, ?, ?, ?)
`

type CreateAccountParams struct {
	Password string
	Admin    bool
	Email    string
	UserID   int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Password,
		arg.Admin,
		arg.Email,
		arg.UserID,
	)
	return err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (
    ap_id,
    attributed_to,
    url,
    host,
    language,
    media_type,
    title,
    content,
    published
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateArticleParams struct {
	ApID         string
	AttributedTo sql.NullString
	Url          sql.NullString
	Host         sql.NullString
	Language     string
	MediaType    string
	Title        string
	Content      string
	Published    sql.NullInt64
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.ApID,
		arg.AttributedTo,
		arg.Url,
		arg.Host,
		arg.Language,
		arg.MediaType,
		arg.Title,
		arg.Content,
		arg.Published,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createLocalUser = `-- name: CreateLocalUser :one
INSERT INTO users (
    ap_id,
    username,
    name,
    trusted,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    private_key
    )
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10) RETURNING id
`

type CreateLocalUserParams struct {
	ApID       string
	Username   sql.NullString
	Name       sql.NullString
	Trusted    bool
	Summary    sql.NullString
	Inbox      string
	Outbox     string
	Followers  string
	PublicKey  string
	PrivateKey string
}

func (q *Queries) CreateLocalUser(ctx context.Context, arg CreateLocalUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createLocalUser,
		arg.ApID,
		arg.Username,
		arg.Name,
		arg.Trusted,
		arg.Summary,
		arg.Inbox,
		arg.Outbox,
		arg.Followers,
		arg.PublicKey,
		arg.PrivateKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteAp = `-- name: DeleteAp :exec
DELETE FROM ap_object_cache
WHERE ap_id = ?
`

func (q *Queries) DeleteAp(ctx context.Context, apID string) error {
	_, err := q.db.ExecContext(ctx, deleteAp, apID)
	return err
}

const editArticle = `-- name: EditArticle :one
INSERT INTO revisions (
    ap_id,
    article_id,
    user_id,
    summary,
    diff,
    reviewed,
    published,
    prev,
    based_on
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type EditArticleParams struct {
	ApID      sql.NullString
	ArticleID int64
	UserID    int64
	Summary   sql.NullString
	Diff      string
	Reviewed  bool
	Published bool
	Prev      sql.NullInt64
	BasedOn   sql.NullInt64
}

func (q *Queries) EditArticle(ctx context.Context, arg EditArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, editArticle,
		arg.ApID,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Reviewed,
		arg.Published,
		arg.Prev,
		arg.BasedOn,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const fileExists = `-- name: FileExists :one
SELECT COUNT(id) == 1 FROM files WHERE digest = ?
`

func (q *Queries) FileExists(ctx context.Context, digest string) (bool, error) {
	row := q.db.QueryRowContext(ctx, fileExists, digest)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const follow = `-- name: Follow :one
INSERT INTO follows (
    follow_ap_id,
    follower_ap_id,
    followee_ap_id,
    follower_inbox_url
) VALUES (?, ?, ?, ?)
RETURNING id
`

type FollowParams struct {
	FollowApID       string
	FollowerApID     string
	FolloweeApID     string
	FollowerInboxUrl sql.NullString
}

func (q *Queries) Follow(ctx context.Context, arg FollowParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, follow,
		arg.FollowApID,
		arg.FollowerApID,
		arg.FolloweeApID,
		arg.FollowerInboxUrl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getApObject = `-- name: GetApObject :one
SELECT ap_id, local_table, local_id, type, raw_json, last_updated, last_fetched
FROM ap_object_cache
WHERE ap_id = ?
`

type GetApObjectRow struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastUpdated sql.NullInt64
	LastFetched sql.NullInt64
}

func (q *Queries) GetApObject(ctx context.Context, apID string) (GetApObjectRow, error) {
	row := q.db.QueryRowContext(ctx, getApObject, apID)
	var i GetApObjectRow
	err := row.Scan(
		&i.ApID,
		&i.LocalTable,
		&i.LocalID,
		&i.Type,
		&i.RawJson,
		&i.LastUpdated,
		&i.LastFetched,
	)
	return i, err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT
    ap_id,
    attributed_to,
    url,
    host,
    language,
    media_type,
    title,
    protected,
    summary,
    content,
    published,
    inserted_at,
    last_updated
FROM articles where id = ?
`

type GetArticleByIDRow struct {
	ApID         string
	AttributedTo sql.NullString
	Url          sql.NullString
	Host         sql.NullString
	Language     string
	MediaType    string
	Title        string
	Protected    bool
	Summary      sql.NullString
	Content      string
	Published    sql.NullInt64
	InsertedAt   int64
	LastUpdated  int64
}

func (q *Queries) GetArticleByID(ctx context.Context, id int64) (GetArticleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.ApID,
		&i.AttributedTo,
		&i.Url,
		&i.Host,
		&i.Language,
		&i.MediaType,
		&i.Title,
		&i.Protected,
		&i.Summary,
		&i.Content,
		&i.Published,
		&i.InsertedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getArticleContent = `-- name: GetArticleContent :one
SELECT content FROM articles WHERE id = ?
`

func (q *Queries) GetArticleContent(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getArticleContent, id)
	var content string
	err := row.Scan(&content)
	return content, err
}

const getArticleIDS = `-- name: GetArticleIDS :one
SELECT
    a.ap_id,
    a.id AS article_id,
    r.id AS rev_id
FROM articles a JOIN revisions r ON r.article_id = a.id
WHERE lower(a.title) = lower(?1)
ORDER BY r.created DESC
LIMIT 1
`

type GetArticleIDSRow struct {
	ApID      string
	ArticleID int64
	RevID     int64
}

func (q *Queries) GetArticleIDS(ctx context.Context, title string) (GetArticleIDSRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleIDS, title)
	var i GetArticleIDSRow
	err := row.Scan(&i.ApID, &i.ArticleID, &i.RevID)
	return i, err
}

const getCollectionActivitiesPage = `-- name: GetCollectionActivitiesPage :many
SELECT
    cache.ap_id,
    cache.raw_json
FROM
    ap_collection_members col
JOIN
    ap_object_cache cache
ON cache.ap_id = col.member_ap_id
WHERE col.collection_ap_id = ?1 AND (
    cache.id < ?2
    OR
    ?2 IS NULL
)
ORDER BY cache.id DESC
LIMIT ?3
`

type GetCollectionActivitiesPageParams struct {
	CollectionID string
	LastID       sql.NullInt64
	PageSize     int64
}

type GetCollectionActivitiesPageRow struct {
	ApID    string
	RawJson []byte
}

func (q *Queries) GetCollectionActivitiesPage(ctx context.Context, arg GetCollectionActivitiesPageParams) ([]GetCollectionActivitiesPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionActivitiesPage, arg.CollectionID, arg.LastID, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionActivitiesPageRow
	for rows.Next() {
		var i GetCollectionActivitiesPageRow
		if err := rows.Scan(&i.ApID, &i.RawJson); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionFirstPage = `-- name: GetCollectionFirstPage :many
SELECT member_ap_id FROM ap_collection_members WHERE collection_ap_id = ? ORDER BY id DESC
`

func (q *Queries) GetCollectionFirstPage(ctx context.Context, collectionApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionFirstPage, collectionApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var member_ap_id string
		if err := rows.Scan(&member_ap_id); err != nil {
			return nil, err
		}
		items = append(items, member_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionStart = `-- name: GetCollectionStart :one
SELECT
    CAST(MAX(cache.id) AS BIGINT) AS start,
    CAST(COUNT(cache.id) AS BIGINT) AS size
FROM
    ap_collection_members col
JOIN
    ap_object_cache cache
ON cache.ap_id = col.member_ap_id
WHERE
    col.collection_ap_id = ?1
ORDER BY cache.id DESC
`

type GetCollectionStartRow struct {
	Start int64
	Size  int64
}

func (q *Queries) GetCollectionStart(ctx context.Context, collectionID string) (GetCollectionStartRow, error) {
	row := q.db.QueryRowContext(ctx, getCollectionStart, collectionID)
	var i GetCollectionStartRow
	err := row.Scan(&i.Start, &i.Size)
	return i, err
}

const getCollectiveByID = `-- name: GetCollectiveByID :one
SELECT
    cache.type,
    i.name,
    i.host,
    i.url,
    i.public_key,
    i.inbox,
    i.outbox,
    i.followers
FROM collectives i
JOIN ap_object_cache cache ON cache.ap_id = i.url
WHERE i.id = ?
LIMIT 1
`

type GetCollectiveByIDRow struct {
	Type      string
	Name      sql.NullString
	Host      string
	Url       sql.NullString
	PublicKey sql.NullString
	Inbox     sql.NullString
	Outbox    sql.NullString
	Followers sql.NullString
}

func (q *Queries) GetCollectiveByID(ctx context.Context, id int64) (GetCollectiveByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCollectiveByID, id)
	var i GetCollectiveByIDRow
	err := row.Scan(
		&i.Type,
		&i.Name,
		&i.Host,
		&i.Url,
		&i.PublicKey,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT
    f.id,
    f.digest,
    f.path,
    f.ap_id,
    f.name,
    f.filename,
    f.type,
    f.mime_type,
    f.size_bytes,
    f.local,
    f.url,
    f.created,
    f.host,
    u.username
FROM files f
LEFT JOIN users u ON u.id = f.uploaded_by
WHERE f.digest = ?
`

type GetFileRow struct {
	ID        int64
	Digest    string
	Path      sql.NullString
	ApID      string
	Name      sql.NullString
	Filename  sql.NullString
	Type      string
	MimeType  string
	SizeBytes sql.NullInt64
	Local     bool
	Url       string
	Created   int64
	Host      sql.NullString
	Username  sql.NullString
}

func (q *Queries) GetFile(ctx context.Context, digest string) (GetFileRow, error) {
	row := q.db.QueryRowContext(ctx, getFile, digest)
	var i GetFileRow
	err := row.Scan(
		&i.ID,
		&i.Digest,
		&i.Path,
		&i.ApID,
		&i.Name,
		&i.Filename,
		&i.Type,
		&i.MimeType,
		&i.SizeBytes,
		&i.Local,
		&i.Url,
		&i.Created,
		&i.Host,
		&i.Username,
	)
	return i, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT follower_ap_id FROM follows WHERE followee_ap_id = ?
`

func (q *Queries) GetFollowers(ctx context.Context, followeeApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, followeeApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var follower_ap_id string
		if err := rows.Scan(&follower_ap_id); err != nil {
			return nil, err
		}
		items = append(items, follower_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignUserData = `-- name: GetForeignUserData :one
SELECT
    u.id,
    u.username,
    u.name,
    u.host,
    u.url,
    u.local,
    u.summary
FROM users u
WHERE u.username = lower(?) AND NOT u.local AND u.host = ?
`

type GetForeignUserDataParams struct {
	LOWER string
	Host  sql.NullString
}

type GetForeignUserDataRow struct {
	ID       int64
	Username sql.NullString
	Name     sql.NullString
	Host     sql.NullString
	Url      sql.NullString
	Local    bool
	Summary  sql.NullString
}

func (q *Queries) GetForeignUserData(ctx context.Context, arg GetForeignUserDataParams) (GetForeignUserDataRow, error) {
	row := q.db.QueryRowContext(ctx, getForeignUserData, arg.LOWER, arg.Host)
	var i GetForeignUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Host,
		&i.Url,
		&i.Local,
		&i.Summary,
	)
	return i, err
}

const getInboxByActorId = `-- name: GetInboxByActorId :one
SELECT u.inbox as inbox FROM users u WHERE u.ap_id = ?1
UNION
SELECT i.inbox as inbox FROM collectives i WHERE i.url = ?1
LIMIT 1
`

func (q *Queries) GetInboxByActorId(ctx context.Context, apID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getInboxByActorId, apID)
	var inbox string
	err := row.Scan(&inbox)
	return inbox, err
}

const getInstanceId = `-- name: GetInstanceId :one
SELECT id from collectives where host = ?
`

func (q *Queries) GetInstanceId(ctx context.Context, host string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getInstanceId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLocalArticleByTitle = `-- name: GetLocalArticleByTitle :one
SELECT
    title,
    summary,
    content,
    protected,
    media_type,
    language
FROM
    articles
where local AND title = ?1
LIMIT 1
`

type GetLocalArticleByTitleRow struct {
	Title     string
	Summary   sql.NullString
	Content   string
	Protected bool
	MediaType string
	Language  string
}

func (q *Queries) GetLocalArticleByTitle(ctx context.Context, title string) (GetLocalArticleByTitleRow, error) {
	row := q.db.QueryRowContext(ctx, getLocalArticleByTitle, title)
	var i GetLocalArticleByTitleRow
	err := row.Scan(
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Protected,
		&i.MediaType,
		&i.Language,
	)
	return i, err
}

const getLocalUserData = `-- name: GetLocalUserData :one
SELECT
    id,
    username,
    name,
    url,
    summary
FROM users
WHERE local AND username = lower(?)
`

type GetLocalUserDataRow struct {
	ID       int64
	Username sql.NullString
	Name     sql.NullString
	Url      sql.NullString
	Summary  sql.NullString
}

func (q *Queries) GetLocalUserData(ctx context.Context, lower string) (GetLocalUserDataRow, error) {
	row := q.db.QueryRowContext(ctx, getLocalUserData, lower)
	var i GetLocalUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Url,
		&i.Summary,
	)
	return i, err
}

const getPrivateKeyByID = `-- name: GetPrivateKeyByID :one
SELECT private_key FROM users WHERE local AND ap_id = ?1
UNION
SELECT private_key FROM collectives WHERE private_key IS NOT NULL AND url = ?1
LIMIT 1
`

func (q *Queries) GetPrivateKeyByID(ctx context.Context, apID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getPrivateKeyByID, apID)
	var private_key string
	err := row.Scan(&private_key)
	return private_key, err
}

const getRevisionList = `-- name: GetRevisionList :many
SELECT
    r.id,
    r.reviewed,
    r.summary,
    a.title,
    u.username,
    r.created
FROM (
    SELECT id, title from articles WHERE lower(title) = lower(?1) LIMIT 1
) a
JOIN revisions r ON r.article_id = a.id
JOIN users u ON r.user_id = u.id
ORDER BY r.created DESC
`

type GetRevisionListRow struct {
	ID       int64
	Reviewed bool
	Summary  sql.NullString
	Title    string
	Username sql.NullString
	Created  int64
}

func (q *Queries) GetRevisionList(ctx context.Context, title string) ([]GetRevisionListRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionList, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionListRow
	for rows.Next() {
		var i GetRevisionListRow
		if err := rows.Scan(
			&i.ID,
			&i.Reviewed,
			&i.Summary,
			&i.Title,
			&i.Username,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisionsByUserId = `-- name: GetRevisionsByUserId :many
SELECT
    r.id,
    a.title,
    r.summary,
    r.reviewed,
    r.created
FROM revisions r
JOIN articles a
ON a.id = r.article_id
WHERE r.user_id = ?
`

type GetRevisionsByUserIdRow struct {
	ID       int64
	Title    string
	Summary  sql.NullString
	Reviewed bool
	Created  int64
}

func (q *Queries) GetRevisionsByUserId(ctx context.Context, userID int64) ([]GetRevisionsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionsByUserIdRow
	for rows.Next() {
		var i GetRevisionsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Reviewed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserApId = `-- name: GetUserApId :one
SELECT ap_id FROM users WHERE local AND username = lower(?1)
UNION
SELECT url AS ap_id FROM collectives WHERE name = lower(?1)
`

func (q *Queries) GetUserApId(ctx context.Context, lower string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserApId, lower)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const getUserFull = `-- name: GetUserFull :one
SELECT
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    created,
    last_updated
FROM users
WHERE local AND ap_id = ?
`

type GetUserFullRow struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	Created     int64
	LastUpdated int64
}

func (q *Queries) GetUserFull(ctx context.Context, apID string) (GetUserFullRow, error) {
	row := q.db.QueryRowContext(ctx, getUserFull, apID)
	var i GetUserFullRow
	err := row.Scan(
		&i.ApID,
		&i.Url,
		&i.Username,
		&i.Name,
		&i.Summary,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
		&i.PublicKey,
		&i.Created,
		&i.LastUpdated,
	)
	return i, err
}

const getUserFullByID = `-- name: GetUserFullByID :one
SELECT
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    created,
    last_updated
FROM users
WHERE id = ?
`

type GetUserFullByIDRow struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	Created     int64
	LastUpdated int64
}

func (q *Queries) GetUserFullByID(ctx context.Context, id int64) (GetUserFullByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserFullByID, id)
	var i GetUserFullByIDRow
	err := row.Scan(
		&i.ApID,
		&i.Url,
		&i.Username,
		&i.Name,
		&i.Summary,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
		&i.PublicKey,
		&i.Created,
		&i.LastUpdated,
	)
	return i, err
}

const getUserKeys = `-- name: GetUserKeys :one
SELECT ap_id, private_key FROM users WHERE local AND id = ?
`

type GetUserKeysRow struct {
	ApID       string
	PrivateKey string
}

func (q *Queries) GetUserKeys(ctx context.Context, id int64) (GetUserKeysRow, error) {
	row := q.db.QueryRowContext(ctx, getUserKeys, id)
	var i GetUserKeysRow
	err := row.Scan(&i.ApID, &i.PrivateKey)
	return i, err
}

const getUserUriById = `-- name: GetUserUriById :one
SELECT ap_id FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserUriById(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserUriById, id)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const insertApObject = `-- name: InsertApObject :exec
INSERT INTO ap_object_cache (ap_id, local_table, local_id, type, raw_json, last_updated, last_fetched)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertApObjectParams struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastUpdated sql.NullInt64
	LastFetched sql.NullInt64
}

func (q *Queries) InsertApObject(ctx context.Context, arg InsertApObjectParams) error {
	_, err := q.db.ExecContext(ctx, insertApObject,
		arg.ApID,
		arg.LocalTable,
		arg.LocalID,
		arg.Type,
		arg.RawJson,
		arg.LastUpdated,
		arg.LastFetched,
	)
	return err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO files (
    local,
    digest,
    path,
    ap_id,
    name,
    filename,
    type,
    mime_type,
    size_bytes,
    uploaded_by,
    url
) VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertFileParams struct {
	Local      bool
	Digest     string
	Path       sql.NullString
	ApID       string
	Name       sql.NullString
	Filename   sql.NullString
	Type       string
	MimeType   string
	SizeBytes  sql.NullInt64
	UploadedBy sql.NullInt64
	Url        string
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.Local,
		arg.Digest,
		arg.Path,
		arg.ApID,
		arg.Name,
		arg.Filename,
		arg.Type,
		arg.MimeType,
		arg.SizeBytes,
		arg.UploadedBy,
		arg.Url,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertInstance = `-- name: InsertInstance :one
INSERT INTO collectives (host, public_key, inbox) VALUES (?, ?, ?) RETURNING id
`

type InsertInstanceParams struct {
	Host      string
	PublicKey sql.NullString
	Inbox     sql.NullString
}

func (q *Queries) InsertInstance(ctx context.Context, arg InsertInstanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertInstance, arg.Host, arg.PublicKey, arg.Inbox)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertOrUpdateApObject = `-- name: InsertOrUpdateApObject :exec
INSERT INTO ap_object_cache (ap_id, local_table, local_id, type, raw_json, last_fetched)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT (ap_id) DO UPDATE
SET type = ?4,
    raw_json = ?5,
    last_updated = cast(strftime('%s','now') as int),
    last_fetched = ?6
`

type InsertOrUpdateApObjectParams struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastFetched sql.NullInt64
}

func (q *Queries) InsertOrUpdateApObject(ctx context.Context, arg InsertOrUpdateApObjectParams) error {
	_, err := q.db.ExecContext(ctx, insertOrUpdateApObject,
		arg.ApID,
		arg.LocalTable,
		arg.LocalID,
		arg.Type,
		arg.RawJson,
		arg.LastFetched,
	)
	return err
}

const insertOrUpdateUser = `-- name: InsertOrUpdateUser :one
INSERT INTO users (
    local,
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    trusted,
    last_updated,
    last_fetched
) VALUES (false, ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, false, (cast(strftime('%s','now') as int)), ?10)
ON CONFLICT (ap_id) DO UPDATE
SET url = ?2,
    username = ?3,
    name = ?4,
    summary = ?5,
    inbox = ?6,
    outbox = ?7,
    followers = ?8,
    public_key = ?9,
    last_updated = cast(strftime('%s','now') as int),
    last_fetched = ?10
RETURNING id
`

type InsertOrUpdateUserParams struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	LastFetched sql.NullInt64
}

func (q *Queries) InsertOrUpdateUser(ctx context.Context, arg InsertOrUpdateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertOrUpdateUser,
		arg.ApID,
		arg.Url,
		arg.Username,
		arg.Name,
		arg.Summary,
		arg.Inbox,
		arg.Outbox,
		arg.Followers,
		arg.PublicKey,
		arg.LastFetched,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertRevision = `-- name: InsertRevision :one
INSERT INTO revisions (
    article_id,
    user_id,
    summary,
    diff,
    published,
    prev
) VALUES (?1, ?2, ?3, ?4, true, ?5)
RETURNING id
`

type InsertRevisionParams struct {
	ArticleID int64
	UserID    int64
	Summary   sql.NullString
	Diff      string
	Prev      sql.NullInt64
}

func (q *Queries) InsertRevision(ctx context.Context, arg InsertRevisionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertRevision,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Prev,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isUserTrusted = `-- name: IsUserTrusted :one
SELECT trusted FROM users where id = ?1 LIMIT 1
`

func (q *Queries) IsUserTrusted(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserTrusted, id)
	var trusted bool
	err := row.Scan(&trusted)
	return trusted, err
}

const outboxForInbox = `-- name: OutboxForInbox :one
SELECT outbox from users where inbox = ?
`

func (q *Queries) OutboxForInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, outboxForInbox, inbox)
	var outbox string
	err := row.Scan(&outbox)
	return outbox, err
}

const updateAp = `-- name: UpdateAp :exec
UPDATE ap_object_cache
SET
    raw_json = ?,
    last_updated = (cast(strftime('%s','now') as int))
WHERE ap_id = ?
`

type UpdateApParams struct {
	RawJson []byte
	ApID    string
}

func (q *Queries) UpdateAp(ctx context.Context, arg UpdateApParams) error {
	_, err := q.db.ExecContext(ctx, updateAp, arg.RawJson, arg.ApID)
	return err
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE articles
SET
    content = ?1,
    last_updated = (cast(strftime('%s','now') as int))
WHERE id = ?2
`

type UpdateArticleParams struct {
	Content string
	ID      int64
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle, arg.Content, arg.ID)
	return err
}

const updateFollowInbox = `-- name: UpdateFollowInbox :exec
UPDATE follows SET follower_inbox_url = ? WHERE follower_ap_id = ?
`

type UpdateFollowInboxParams struct {
	FollowerInboxUrl sql.NullString
	FollowerApID     string
}

func (q *Queries) UpdateFollowInbox(ctx context.Context, arg UpdateFollowInboxParams) error {
	_, err := q.db.ExecContext(ctx, updateFollowInbox, arg.FollowerInboxUrl, arg.FollowerApID)
	return err
}

const updateRevisionApId = `-- name: UpdateRevisionApId :exec
UPDATE revisions SET ap_id = ? WHERE id = ?
`

type UpdateRevisionApIdParams struct {
	ApID sql.NullString
	ID   int64
}

func (q *Queries) UpdateRevisionApId(ctx context.Context, arg UpdateRevisionApIdParams) error {
	_, err := q.db.ExecContext(ctx, updateRevisionApId, arg.ApID, arg.ID)
	return err
}

const userExists = `-- name: UserExists :one
SELECT COUNT(id) == 1 FROM users WHERE ap_id = ?
`

func (q *Queries) UserExists(ctx context.Context, apID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, apID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
)

const addToCollection = `-- name: AddToCollection :one
INSERT INTO ap_collection_members (collection_ap_id, member_ap_id) VALUES (?, ?) RETURNING id
`

type AddToCollectionParams struct {
	CollectionApID string
	MemberApID     string
}

func (q *Queries) AddToCollection(ctx context.Context, arg AddToCollectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addToCollection, arg.CollectionApID, arg.MemberApID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const authUserByEmail = `-- name: AuthUserByEmail :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND a.email = ?1
LIMIT 1
`

type AuthUserByEmailRow struct {
	UserID    int64
	AccountID int64
	Username  string
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByEmail(ctx context.Context, email string) (AuthUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByEmail, email)
	var i AuthUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const authUserByUsername = `-- name: AuthUserByUsername :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND u.username = ?1
LIMIT 1
`

type AuthUserByUsernameRow struct {
	UserID    int64
	AccountID int64
	Username  string
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByUsername(ctx context.Context, username string) (AuthUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByUsername, username)
	var i AuthUserByUsernameRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO 
    accounts (password, admin, email, user_id)
VALUES 
    (?, ?, ?, ?)
`

type CreateAccountParams struct {
	Password string
	Admin    bool
	Email    string
	UserID   int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Password,
		arg.Admin,
		arg.Email,
		arg.UserID,
	)
	return err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (
    ap_id,
    url,
    instance_id,
    language,
    media_type,
    title,
    content
) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateArticleParams struct {
	ApID       string
	Url        sql.NullString
	InstanceID sql.NullInt64
	Language   string
	MediaType  string
	Title      string
	Content    string
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.ApID,
		arg.Url,
		arg.InstanceID,
		arg.Language,
		arg.MediaType,
		arg.Title,
		arg.Content,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createLocalUser = `-- name: CreateLocalUser :one
INSERT INTO users (
    ap_id,
    username,
    name,
    trusted,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    private_key
    )
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10) RETURNING id
`

type CreateLocalUserParams struct {
	ApID       string
	Username   string
	Name       string
	Trusted    bool
	Summary    sql.NullString
	Inbox      string
	Outbox     string
	Followers  string
	PublicKey  string
	PrivateKey string
}

func (q *Queries) CreateLocalUser(ctx context.Context, arg CreateLocalUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createLocalUser,
		arg.ApID,
		arg.Username,
		arg.Name,
		arg.Trusted,
		arg.Summary,
		arg.Inbox,
		arg.Outbox,
		arg.Followers,
		arg.PublicKey,
		arg.PrivateKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const editArticle = `-- name: EditArticle :one
INSERT INTO revisions (
    ap_id,
    article_id,
    user_id,
    summary,
    diff,
    reviewed,
    published,
    prev,
    based_on
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type EditArticleParams struct {
	ApID      sql.NullString
	ArticleID int64
	UserID    int64
	Summary   sql.NullString
	Diff      string
	Reviewed  bool
	Published bool
	Prev      sql.NullInt64
	BasedOn   sql.NullInt64
}

func (q *Queries) EditArticle(ctx context.Context, arg EditArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, editArticle,
		arg.ApID,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Reviewed,
		arg.Published,
		arg.Prev,
		arg.BasedOn,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const fileExists = `-- name: FileExists :one
SELECT COUNT(id) == 1 FROM files WHERE digest = ?
`

func (q *Queries) FileExists(ctx context.Context, digest string) (bool, error) {
	row := q.db.QueryRowContext(ctx, fileExists, digest)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getArticleContent = `-- name: GetArticleContent :one
SELECT content FROM articles WHERE id = ?
`

func (q *Queries) GetArticleContent(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getArticleContent, id)
	var content string
	err := row.Scan(&content)
	return content, err
}

const getArticleIDS = `-- name: GetArticleIDS :one
SELECT
    a.ap_id,
    a.id AS article_id,
    r.id AS rev_id
FROM articles a JOIN revisions r ON r.article_id = a.id
WHERE lower(a.title) = lower(?1)
ORDER BY r.created DESC
LIMIT 1
`

type GetArticleIDSRow struct {
	ApID      string
	ArticleID int64
	RevID     int64
}

func (q *Queries) GetArticleIDS(ctx context.Context, title string) (GetArticleIDSRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleIDS, title)
	var i GetArticleIDSRow
	err := row.Scan(&i.ApID, &i.ArticleID, &i.RevID)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT
    f.id,
    f.digest,
    f.path,
    f.ap_id,
    f.name,
    f.filename,
    f.type,
    f.mime_type,
    f.size_bytes,
    f.local,
    f.url,
    f.created,
    u.username,
    u.domain
FROM files f
LEFT JOIN users u ON u.id = f.uploaded_by
WHERE f.digest = ?
`

type GetFileRow struct {
	ID        int64
	Digest    string
	Path      sql.NullString
	ApID      string
	Name      sql.NullString
	Filename  sql.NullString
	Type      string
	MimeType  string
	SizeBytes sql.NullInt64
	Local     bool
	Url       string
	Created   int64
	Username  sql.NullString
	Domain    sql.NullString
}

func (q *Queries) GetFile(ctx context.Context, digest string) (GetFileRow, error) {
	row := q.db.QueryRowContext(ctx, getFile, digest)
	var i GetFileRow
	err := row.Scan(
		&i.ID,
		&i.Digest,
		&i.Path,
		&i.ApID,
		&i.Name,
		&i.Filename,
		&i.Type,
		&i.MimeType,
		&i.SizeBytes,
		&i.Local,
		&i.Url,
		&i.Created,
		&i.Username,
		&i.Domain,
	)
	return i, err
}

const getForeignUserData = `-- name: GetForeignUserData :one
SELECT
    id,
    username,
    name,
    domain,
    url,
    local,
    summary
FROM users
WHERE username = lower(?) AND NOT local AND domain = ?
`

type GetForeignUserDataParams struct {
	LOWER  string
	Domain sql.NullString
}

type GetForeignUserDataRow struct {
	ID       int64
	Username string
	Name     string
	Domain   sql.NullString
	Url      sql.NullString
	Local    bool
	Summary  sql.NullString
}

func (q *Queries) GetForeignUserData(ctx context.Context, arg GetForeignUserDataParams) (GetForeignUserDataRow, error) {
	row := q.db.QueryRowContext(ctx, getForeignUserData, arg.LOWER, arg.Domain)
	var i GetForeignUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Domain,
		&i.Url,
		&i.Local,
		&i.Summary,
	)
	return i, err
}

const getInstanceId = `-- name: GetInstanceId :one
SELECT id from instances where hostname = ?
`

func (q *Queries) GetInstanceId(ctx context.Context, hostname string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getInstanceId, hostname)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getLocalArticleByTitle = `-- name: GetLocalArticleByTitle :one
SELECT
    title,
    summary,
    content,
    protected,
    media_type,
    language
FROM
    articles
where local AND title = ?1
LIMIT 1
`

type GetLocalArticleByTitleRow struct {
	Title     string
	Summary   sql.NullString
	Content   string
	Protected bool
	MediaType string
	Language  string
}

func (q *Queries) GetLocalArticleByTitle(ctx context.Context, title string) (GetLocalArticleByTitleRow, error) {
	row := q.db.QueryRowContext(ctx, getLocalArticleByTitle, title)
	var i GetLocalArticleByTitleRow
	err := row.Scan(
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Protected,
		&i.MediaType,
		&i.Language,
	)
	return i, err
}

const getLocalUserData = `-- name: GetLocalUserData :one
SELECT
    id,
    username,
    name,
    url,
    summary
FROM users
WHERE local AND username = lower(?)
`

type GetLocalUserDataRow struct {
	ID       int64
	Username string
	Name     string
	Url      sql.NullString
	Summary  sql.NullString
}

func (q *Queries) GetLocalUserData(ctx context.Context, lower string) (GetLocalUserDataRow, error) {
	row := q.db.QueryRowContext(ctx, getLocalUserData, lower)
	var i GetLocalUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Url,
		&i.Summary,
	)
	return i, err
}

const getRevisionList = `-- name: GetRevisionList :many
SELECT
    r.id,
    r.reviewed,
    r.summary,
    a.title,
    u.username,
    r.created
FROM (
    SELECT id, title from articles WHERE lower(title) = lower(?1) LIMIT 1
) a
JOIN revisions r ON r.article_id = a.id
JOIN users u ON r.user_id = u.id
ORDER BY r.created DESC
`

type GetRevisionListRow struct {
	ID       int64
	Reviewed bool
	Summary  sql.NullString
	Title    string
	Username string
	Created  int64
}

func (q *Queries) GetRevisionList(ctx context.Context, title string) ([]GetRevisionListRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionList, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionListRow
	for rows.Next() {
		var i GetRevisionListRow
		if err := rows.Scan(
			&i.ID,
			&i.Reviewed,
			&i.Summary,
			&i.Title,
			&i.Username,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisionsByUserId = `-- name: GetRevisionsByUserId :many
SELECT
    r.id,
    a.title,
    r.summary,
    r.reviewed,
    r.created
FROM revisions r
JOIN articles a
ON a.id = r.article_id
WHERE r.user_id = ?
`

type GetRevisionsByUserIdRow struct {
	ID       int64
	Title    string
	Summary  sql.NullString
	Reviewed bool
	Created  int64
}

func (q *Queries) GetRevisionsByUserId(ctx context.Context, userID int64) ([]GetRevisionsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionsByUserIdRow
	for rows.Next() {
		var i GetRevisionsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Reviewed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFull = `-- name: GetUserFull :one
SELECT
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    created,
    last_updated
FROM users
WHERE local AND ap_id = ?
`

type GetUserFullRow struct {
	ApID        string
	Url         sql.NullString
	Username    string
	Name        string
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	Created     int64
	LastUpdated int64
}

func (q *Queries) GetUserFull(ctx context.Context, apID string) (GetUserFullRow, error) {
	row := q.db.QueryRowContext(ctx, getUserFull, apID)
	var i GetUserFullRow
	err := row.Scan(
		&i.ApID,
		&i.Url,
		&i.Username,
		&i.Name,
		&i.Summary,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
		&i.PublicKey,
		&i.Created,
		&i.LastUpdated,
	)
	return i, err
}

const insertApObject = `-- name: InsertApObject :exec
INSERT INTO ap_object_cache (ap_id, local_table, local_id, type, raw_json, last_updated, last_fetched)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertApObjectParams struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     sql.NullString
	LastUpdated sql.NullInt64
	LastFetched sql.NullInt64
}

func (q *Queries) InsertApObject(ctx context.Context, arg InsertApObjectParams) error {
	_, err := q.db.ExecContext(ctx, insertApObject,
		arg.ApID,
		arg.LocalTable,
		arg.LocalID,
		arg.Type,
		arg.RawJson,
		arg.LastUpdated,
		arg.LastFetched,
	)
	return err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO files (
    local,
    digest,
    path,
    ap_id,
    name,
    filename,
    type,
    mime_type,
    size_bytes,
    uploaded_by,
    url
) VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertFileParams struct {
	Local      bool
	Digest     string
	Path       sql.NullString
	ApID       string
	Name       sql.NullString
	Filename   sql.NullString
	Type       string
	MimeType   string
	SizeBytes  sql.NullInt64
	UploadedBy sql.NullInt64
	Url        string
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.Local,
		arg.Digest,
		arg.Path,
		arg.ApID,
		arg.Name,
		arg.Filename,
		arg.Type,
		arg.MimeType,
		arg.SizeBytes,
		arg.UploadedBy,
		arg.Url,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertInstance = `-- name: InsertInstance :one
INSERT INTO instances (hostname, public_key, inbox) VALUES (?, ?, ?) RETURNING id
`

type InsertInstanceParams struct {
	Hostname  string
	PublicKey sql.NullString
	Inbox     sql.NullString
}

func (q *Queries) InsertInstance(ctx context.Context, arg InsertInstanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertInstance, arg.Hostname, arg.PublicKey, arg.Inbox)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertRevision = `-- name: InsertRevision :exec
INSERT INTO revisions (
    ap_id,
    article_id,
    user_id,
    summary,
    diff,
    published,
    prev
) VALUES (?1, ?2, ?3, ?4, ?5, true, ?6)
`

type InsertRevisionParams struct {
	ApID      sql.NullString
	ArticleID int64
	UserID    int64
	Summary   sql.NullString
	Diff      string
	Prev      sql.NullInt64
}

func (q *Queries) InsertRevision(ctx context.Context, arg InsertRevisionParams) error {
	_, err := q.db.ExecContext(ctx, insertRevision,
		arg.ApID,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Prev,
	)
	return err
}

const isUserTrusted = `-- name: IsUserTrusted :one
SELECT trusted FROM users where id = ?1 LIMIT 1
`

func (q *Queries) IsUserTrusted(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserTrusted, id)
	var trusted bool
	err := row.Scan(&trusted)
	return trusted, err
}

const outboxForInbox = `-- name: OutboxForInbox :one
SELECT outbox from users where inbox = ?
`

func (q *Queries) OutboxForInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, outboxForInbox, inbox)
	var outbox string
	err := row.Scan(&outbox)
	return outbox, err
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE articles
SET
    content = ?1,
    last_updated = (cast(strftime('%s','now') as int))
WHERE id = ?2
`

type UpdateArticleParams struct {
	Content string
	ID      int64
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle, arg.Content, arg.ID)
	return err
}

const userExists = `-- name: UserExists :one
SELECT COUNT(id) == 1 FROM users WHERE ap_id = ?
`

func (q *Queries) UserExists(ctx context.Context, apID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, apID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const userIdByInbox = `-- name: UserIdByInbox :one
SELECT ap_id from users where inbox = ?
`

func (q *Queries) UserIdByInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, userIdByInbox, inbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const userIdByOutbox = `-- name: UserIdByOutbox :one
SELECT ap_id from users where outbox = ?
`

func (q *Queries) UserIdByOutbox(ctx context.Context, outbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, userIdByOutbox, outbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
)

const acceptFollow = `-- name: AcceptFollow :exec
UPDATE follows
SET approved = TRUE
WHERE follow_ap_id = ?
`

func (q *Queries) AcceptFollow(ctx context.Context, followApID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, acceptFollow, followApID)
	return err
}

const actorIdByInbox = `-- name: ActorIdByInbox :one
SELECT ap_id FROM users u WHERE u.inbox = ?1
UNION
SELECT url AS ap_id FROM collectives i WHERE i.inbox = ?1
`

func (q *Queries) ActorIdByInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, actorIdByInbox, inbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const actorIdByOutbox = `-- name: ActorIdByOutbox :one
SELECT ap_id from users u where u.outbox = ?1
UNION
SELECT url as ap_id FROM collectives i WHERE i.outbox = ?1
`

func (q *Queries) ActorIdByOutbox(ctx context.Context, outbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, actorIdByOutbox, outbox)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const addToCollection = `-- name: AddToCollection :one
INSERT INTO ap_collection_members (collection_ap_id, member_ap_id) VALUES (?, ?) RETURNING id
`

type AddToCollectionParams struct {
	CollectionApID string
	MemberApID     string
}

func (q *Queries) AddToCollection(ctx context.Context, arg AddToCollectionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addToCollection, arg.CollectionApID, arg.MemberApID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const apExists = `-- name: ApExists :one
SELECT EXISTS(SELECT TRUE FROM ap_object_cache WHERE ap_id = ?) AS BOOLEAN
`

func (q *Queries) ApExists(ctx context.Context, apID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, apExists, apID)
	var boolean int64
	err := row.Scan(&boolean)
	return boolean, err
}

const articleTitleExists = `-- name: ArticleTitleExists :one
SELECT EXISTS (
    SELECT TRUE
    FROM articles
    WHERE lower(title) = lower(?) AND author = ? AND host = ?
) AS BOOLEAN
`

type ArticleTitleExistsParams struct {
	LOWER  string
	Author sql.NullString
	Host   sql.NullString
}

func (q *Queries) ArticleTitleExists(ctx context.Context, arg ArticleTitleExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, articleTitleExists, arg.LOWER, arg.Author, arg.Host)
	var boolean int64
	err := row.Scan(&boolean)
	return boolean, err
}

const authUserByEmail = `-- name: AuthUserByEmail :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.ap_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND a.email = ?1
LIMIT 1
`

type AuthUserByEmailRow struct {
	UserID    int64
	AccountID int64
	ApID      string
	Username  sql.NullString
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByEmail(ctx context.Context, email string) (AuthUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByEmail, email)
	var i AuthUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.ApID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const authUserByUsername = `-- name: AuthUserByUsername :one
SELECT
    u.id AS user_id,
    a.id AS account_id,
    u.ap_id,
    u.username,
    a.password,
    a.admin
FROM users AS u
JOIN accounts AS a
ON a.user_id = u.id
WHERE u.local AND u.username = ?1
LIMIT 1
`

type AuthUserByUsernameRow struct {
	UserID    int64
	AccountID int64
	ApID      string
	Username  sql.NullString
	Password  string
	Admin     bool
}

func (q *Queries) AuthUserByUsername(ctx context.Context, username sql.NullString) (AuthUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, authUserByUsername, username)
	var i AuthUserByUsernameRow
	err := row.Scan(
		&i.UserID,
		&i.AccountID,
		&i.ApID,
		&i.Username,
		&i.Password,
		&i.Admin,
	)
	return i, err
}

const collectionContains = `-- name: CollectionContains :one
SELECT EXISTS(SELECT TRUE FROM ap_collection_members WHERE collection_ap_id = ? AND member_ap_id = ?)
`

type CollectionContainsParams struct {
	CollectionApID string
	MemberApID     string
}

func (q *Queries) CollectionContains(ctx context.Context, arg CollectionContainsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, collectionContains, arg.CollectionApID, arg.MemberApID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const collectionMembersIRIs = `-- name: CollectionMembersIRIs :many
SELECT member_ap_id FROM ap_collection_members WHERE collection_ap_id = ?
`

func (q *Queries) CollectionMembersIRIs(ctx context.Context, collectionApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, collectionMembersIRIs, collectionApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var member_ap_id string
		if err := rows.Scan(&member_ap_id); err != nil {
			return nil, err
		}
		items = append(items, member_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO 
    accounts (password, admin, email, user_id)
VALUES 
    (?, ?, ?, ?)
`

type CreateAccountParams struct {
	Password string
	Admin    bool
	Email    string
	UserID   int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Password,
		arg.Admin,
		arg.Email,
		arg.UserID,
	)
	return err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (
    local,
    ap_id,
    author,
    attributed_to,
    url,
    language,
    media_type,
    title,
    host,
    type,
    protected,
    summary,
    content,
    published,
    last_updated,
    last_fetched
) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16)
ON CONFLICT (ap_id) DO UPDATE
SET
    url = ?5,
    language = ?6,
    media_type = ?7,
    title = ?8,
    host = ?9,
    type = ?10,
    protected = ?11,
    summary = ?12,
    content = ?13,
    published = ?14,
    last_updated = ?15,
    last_fetched = ?16
RETURNING id
`

type CreateArticleParams struct {
	Local        bool
	ApID         string
	Author       sql.NullString
	AttributedTo sql.NullString
	Url          sql.NullString
	Language     string
	MediaType    string
	Title        string
	Host         sql.NullString
	Type         string
	Protected    bool
	Summary      sql.NullString
	Content      string
	Published    sql.NullInt64
	LastUpdated  int64
	LastFetched  sql.NullInt64
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Local,
		arg.ApID,
		arg.Author,
		arg.AttributedTo,
		arg.Url,
		arg.Language,
		arg.MediaType,
		arg.Title,
		arg.Host,
		arg.Type,
		arg.Protected,
		arg.Summary,
		arg.Content,
		arg.Published,
		arg.LastUpdated,
		arg.LastFetched,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createLocalUser = `-- name: CreateLocalUser :one
INSERT INTO users (
    ap_id,
    username,
    name,
    host,
    trusted,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    private_key
    )
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11) RETURNING id
`

type CreateLocalUserParams struct {
	ApID       string
	Username   sql.NullString
	Name       sql.NullString
	Host       sql.NullString
	Trusted    bool
	Summary    sql.NullString
	Inbox      string
	Outbox     string
	Followers  string
	PublicKey  string
	PrivateKey string
}

func (q *Queries) CreateLocalUser(ctx context.Context, arg CreateLocalUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createLocalUser,
		arg.ApID,
		arg.Username,
		arg.Name,
		arg.Host,
		arg.Trusted,
		arg.Summary,
		arg.Inbox,
		arg.Outbox,
		arg.Followers,
		arg.PublicKey,
		arg.PrivateKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteAp = `-- name: DeleteAp :exec
DELETE FROM ap_object_cache
WHERE ap_id = ?
`

func (q *Queries) DeleteAp(ctx context.Context, apID string) error {
	_, err := q.db.ExecContext(ctx, deleteAp, apID)
	return err
}

const editArticle = `-- name: EditArticle :one
INSERT INTO revisions (
    ap_id,
    article_id,
    user_id,
    summary,
    diff,
    reviewed,
    published,
    prev,
    based_on
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type EditArticleParams struct {
	ApID      sql.NullString
	ArticleID int64
	UserID    sql.NullInt64
	Summary   sql.NullString
	Diff      string
	Reviewed  bool
	Published bool
	Prev      sql.NullInt64
	BasedOn   sql.NullInt64
}

func (q *Queries) EditArticle(ctx context.Context, arg EditArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, editArticle,
		arg.ApID,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Reviewed,
		arg.Published,
		arg.Prev,
		arg.BasedOn,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const fileExists = `-- name: FileExists :one
SELECT COUNT(id) == 1 FROM files WHERE digest = ?
`

func (q *Queries) FileExists(ctx context.Context, digest string) (bool, error) {
	row := q.db.QueryRowContext(ctx, fileExists, digest)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const follow = `-- name: Follow :one
INSERT INTO follows (
    follow_ap_id,
    follower_ap_id,
    followee_ap_id,
    follower_inbox_url
) VALUES (?, ?, ?, ?)
RETURNING id
`

type FollowParams struct {
	FollowApID       sql.NullString
	FollowerApID     string
	FolloweeApID     string
	FollowerInboxUrl sql.NullString
}

func (q *Queries) Follow(ctx context.Context, arg FollowParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, follow,
		arg.FollowApID,
		arg.FollowerApID,
		arg.FolloweeApID,
		arg.FollowerInboxUrl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const follows = `-- name: Follows :one
SELECT EXISTS(
    SELECT TRUE
    FROM follows
    WHERE follower_ap_id = ? AND followee_ap_id = ?
)
`

type FollowsParams struct {
	FollowerApID string
	FolloweeApID string
}

func (q *Queries) Follows(ctx context.Context, arg FollowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, follows, arg.FollowerApID, arg.FolloweeApID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getActorData = `-- name: GetActorData :one
SELECT
    id,
    username as name,
    host,
    ap_id,
    url,
    summary,
    'user' AS type
FROM users u WHERE u.username = lower(?1) AND u.host = ?2
UNION
SELECT
    id,
    name,
    host,
    url as ap_id,
    url,
    summary,
    'group' AS type
FROM collectives c WHERE c.name = lower(?1) AND c.host = ?2
`

type GetActorDataParams struct {
	LOWER string
	Host  sql.NullString
}

type GetActorDataRow struct {
	ID      int64
	Name    sql.NullString
	Host    sql.NullString
	ApID    string
	Url     sql.NullString
	Summary sql.NullString
	Type    string
}

func (q *Queries) GetActorData(ctx context.Context, arg GetActorDataParams) (GetActorDataRow, error) {
	row := q.db.QueryRowContext(ctx, getActorData, arg.LOWER, arg.Host)
	var i GetActorDataRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Host,
		&i.ApID,
		&i.Url,
		&i.Summary,
		&i.Type,
	)
	return i, err
}

const getActorIRI = `-- name: GetActorIRI :one
SELECT ap_id FROM users u WHERE username = lower(?1) AND u.host = ?2
UNION
SELECT url AS ap_id FROM collectives c WHERE c.name = lower(?1) AND c.host = ?2
LIMIT 1
`

type GetActorIRIParams struct {
	LOWER string
	Host  sql.NullString
}

func (q *Queries) GetActorIRI(ctx context.Context, arg GetActorIRIParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getActorIRI, arg.LOWER, arg.Host)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const getApObject = `-- name: GetApObject :one
SELECT ap_id, local_table, local_id, type, raw_json, last_updated, last_fetched
FROM ap_object_cache
WHERE ap_id = ?
`

type GetApObjectRow struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastUpdated sql.NullInt64
	LastFetched sql.NullInt64
}

func (q *Queries) GetApObject(ctx context.Context, apID string) (GetApObjectRow, error) {
	row := q.db.QueryRowContext(ctx, getApObject, apID)
	var i GetApObjectRow
	err := row.Scan(
		&i.ApID,
		&i.LocalTable,
		&i.LocalID,
		&i.Type,
		&i.RawJson,
		&i.LastUpdated,
		&i.LastFetched,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one
SELECT
    art.title,
    art.summary,
    art.content,
    art.protected,
    art.media_type,
    art.language,
    art.url,
    art.published,
    art.last_updated,
    art.host,
    att.name AS author
FROM
    articles AS art
JOIN (
    SELECT username AS name, ap_id AS id FROM users WHERE users.username = ?2
    UNION
    SELECT name AS name, url AS id FROM collectives WHERE collectives.name = ?2
) AS att ON att.id = art.attributed_to
where lower(art.title) = ?1 AND art.host = ?3
LIMIT 1
`

type GetArticleParams struct {
	Title    string
	Username sql.NullString
	Host     sql.NullString
}

type GetArticleRow struct {
	Title       string
	Summary     sql.NullString
	Content     string
	Protected   bool
	MediaType   string
	Language    string
	Url         sql.NullString
	Published   sql.NullInt64
	LastUpdated int64
	Host        sql.NullString
	Author      sql.NullString
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (GetArticleRow, error) {
	row := q.db.QueryRowContext(ctx, getArticle, arg.Title, arg.Username, arg.Host)
	var i GetArticleRow
	err := row.Scan(
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Protected,
		&i.MediaType,
		&i.Language,
		&i.Url,
		&i.Published,
		&i.LastUpdated,
		&i.Host,
		&i.Author,
	)
	return i, err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT
    ap_id,
    attributed_to,
    url,
    host,
    language,
    media_type,
    title,
    protected,
    summary,
    content,
    published,
    inserted_at,
    last_updated
FROM articles where id = ?
`

type GetArticleByIDRow struct {
	ApID         string
	AttributedTo sql.NullString
	Url          sql.NullString
	Host         sql.NullString
	Language     string
	MediaType    string
	Title        string
	Protected    bool
	Summary      sql.NullString
	Content      string
	Published    sql.NullInt64
	InsertedAt   int64
	LastUpdated  int64
}

func (q *Queries) GetArticleByID(ctx context.Context, id int64) (GetArticleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.ApID,
		&i.AttributedTo,
		&i.Url,
		&i.Host,
		&i.Language,
		&i.MediaType,
		&i.Title,
		&i.Protected,
		&i.Summary,
		&i.Content,
		&i.Published,
		&i.InsertedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getArticleByIRI = `-- name: GetArticleByIRI :one
SELECT
    ap_id,
    attributed_to,
    url,
    host,
    language,
    media_type,
    title,
    protected,
    summary,
    content,
    published,
    inserted_at,
    last_updated
FROM articles where ap_id = ?
`

type GetArticleByIRIRow struct {
	ApID         string
	AttributedTo sql.NullString
	Url          sql.NullString
	Host         sql.NullString
	Language     string
	MediaType    string
	Title        string
	Protected    bool
	Summary      sql.NullString
	Content      string
	Published    sql.NullInt64
	InsertedAt   int64
	LastUpdated  int64
}

func (q *Queries) GetArticleByIRI(ctx context.Context, apID string) (GetArticleByIRIRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByIRI, apID)
	var i GetArticleByIRIRow
	err := row.Scan(
		&i.ApID,
		&i.AttributedTo,
		&i.Url,
		&i.Host,
		&i.Language,
		&i.MediaType,
		&i.Title,
		&i.Protected,
		&i.Summary,
		&i.Content,
		&i.Published,
		&i.InsertedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getArticleContent = `-- name: GetArticleContent :one
SELECT content FROM articles WHERE id = ?
`

func (q *Queries) GetArticleContent(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getArticleContent, id)
	var content string
	err := row.Scan(&content)
	return content, err
}

const getArticleContentByIRI = `-- name: GetArticleContentByIRI :one
SELECT id, content FROM articles WHERE ap_id = ?
`

type GetArticleContentByIRIRow struct {
	ID      int64
	Content string
}

func (q *Queries) GetArticleContentByIRI(ctx context.Context, apID string) (GetArticleContentByIRIRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleContentByIRI, apID)
	var i GetArticleContentByIRIRow
	err := row.Scan(&i.ID, &i.Content)
	return i, err
}

const getArticleIDS = `-- name: GetArticleIDS :one
SELECT
    art.id,
    art.ap_id,
    r.id AS rev_id
FROM articles art
JOIN (
    SELECT username AS name, ap_id AS id FROM users WHERE users.username = ?1
    UNION
    SELECT name AS name, url AS id FROM collectives WHERE collectives.name = ?1
) AS att ON att.id = art.attributed_to
JOIN revisions r ON r.article_id = art.id
WHERE LOWER(art.title) = LOWER(?2) AND art.host = ?3
ORDER BY r.created DESC
LIMIT 1
`

type GetArticleIDSParams struct {
	Author sql.NullString
	Title  string
	Host   sql.NullString
}

type GetArticleIDSRow struct {
	ID    int64
	ApID  string
	RevID int64
}

func (q *Queries) GetArticleIDS(ctx context.Context, arg GetArticleIDSParams) (GetArticleIDSRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleIDS, arg.Author, arg.Title, arg.Host)
	var i GetArticleIDSRow
	err := row.Scan(&i.ID, &i.ApID, &i.RevID)
	return i, err
}

const getArticleIdByIri = `-- name: GetArticleIdByIri :one
SELECT id FROM articles WHERE ap_id = ? LIMIT 1
`

func (q *Queries) GetArticleIdByIri(ctx context.Context, apID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getArticleIdByIri, apID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getArticlesByActorId = `-- name: GetArticlesByActorId :many
SELECT
    title,
    published
FROM articles
WHERE attributed_to = ?
`

type GetArticlesByActorIdRow struct {
	Title     string
	Published sql.NullInt64
}

func (q *Queries) GetArticlesByActorId(ctx context.Context, attributedTo sql.NullString) ([]GetArticlesByActorIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesByActorId, attributedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticlesByActorIdRow
	for rows.Next() {
		var i GetArticlesByActorIdRow
		if err := rows.Scan(&i.Title, &i.Published); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthor = `-- name: GetAuthor :one
SELECT username AS name, host, 'person' AS actor_type FROM users WHERE ap_id = ?1
UNION
SELECT name AS name, host, 'collective' AS actor_type FROM collectives WHERE url = ?1
LIMIT 1
`

type GetAuthorRow struct {
	Name      sql.NullString
	Host      sql.NullString
	ActorType string
}

func (q *Queries) GetAuthor(ctx context.Context, apID string) (GetAuthorRow, error) {
	row := q.db.QueryRowContext(ctx, getAuthor, apID)
	var i GetAuthorRow
	err := row.Scan(&i.Name, &i.Host, &i.ActorType)
	return i, err
}

const getCollectionActivitiesPage = `-- name: GetCollectionActivitiesPage :many
SELECT
    cache.ap_id,
    cache.raw_json
FROM
    ap_collection_members col
JOIN
    ap_object_cache cache
ON cache.ap_id = col.member_ap_id
WHERE col.collection_ap_id = ?1 AND (
    cache.id < ?2
    OR
    ?2 IS NULL
)
ORDER BY cache.id DESC
LIMIT ?3
`

type GetCollectionActivitiesPageParams struct {
	CollectionID string
	LastID       sql.NullInt64
	PageSize     int64
}

type GetCollectionActivitiesPageRow struct {
	ApID    string
	RawJson []byte
}

func (q *Queries) GetCollectionActivitiesPage(ctx context.Context, arg GetCollectionActivitiesPageParams) ([]GetCollectionActivitiesPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionActivitiesPage, arg.CollectionID, arg.LastID, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionActivitiesPageRow
	for rows.Next() {
		var i GetCollectionActivitiesPageRow
		if err := rows.Scan(&i.ApID, &i.RawJson); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionFirstPage = `-- name: GetCollectionFirstPage :many
SELECT member_ap_id FROM ap_collection_members WHERE collection_ap_id = ? ORDER BY id DESC
`

func (q *Queries) GetCollectionFirstPage(ctx context.Context, collectionApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionFirstPage, collectionApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var member_ap_id string
		if err := rows.Scan(&member_ap_id); err != nil {
			return nil, err
		}
		items = append(items, member_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionStart = `-- name: GetCollectionStart :one
SELECT
    CAST(MAX(cache.id) AS BIGINT) AS start,
    CAST(COUNT(cache.id) AS BIGINT) AS size
FROM
    ap_collection_members col
JOIN
    ap_object_cache cache
ON cache.ap_id = col.member_ap_id
WHERE
    col.collection_ap_id = ?1
ORDER BY cache.id DESC
`

type GetCollectionStartRow struct {
	Start int64
	Size  int64
}

func (q *Queries) GetCollectionStart(ctx context.Context, collectionID string) (GetCollectionStartRow, error) {
	row := q.db.QueryRowContext(ctx, getCollectionStart, collectionID)
	var i GetCollectionStartRow
	err := row.Scan(&i.Start, &i.Size)
	return i, err
}

const getCollectiveByID = `-- name: GetCollectiveByID :one
SELECT
    cache.type,
    i.name,
    i.host,
    i.url,
    i.public_key,
    i.inbox,
    i.outbox,
    i.followers
FROM collectives i
JOIN ap_object_cache cache ON cache.ap_id = i.url
WHERE i.id = ?
LIMIT 1
`

type GetCollectiveByIDRow struct {
	Type      string
	Name      sql.NullString
	Host      string
	Url       sql.NullString
	PublicKey sql.NullString
	Inbox     sql.NullString
	Outbox    sql.NullString
	Followers sql.NullString
}

func (q *Queries) GetCollectiveByID(ctx context.Context, id int64) (GetCollectiveByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCollectiveByID, id)
	var i GetCollectiveByIDRow
	err := row.Scan(
		&i.Type,
		&i.Name,
		&i.Host,
		&i.Url,
		&i.PublicKey,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT
    f.id,
    f.digest,
    f.path,
    f.ap_id,
    f.name,
    f.filename,
    f.type,
    f.mime_type,
    f.size_bytes,
    f.local,
    f.url,
    f.created,
    f.host,
    u.username
FROM files f
LEFT JOIN users u ON u.id = f.uploaded_by
WHERE f.digest = ?
`

type GetFileRow struct {
	ID        int64
	Digest    string
	Path      sql.NullString
	ApID      string
	Name      sql.NullString
	Filename  sql.NullString
	Type      string
	MimeType  string
	SizeBytes sql.NullInt64
	Local     bool
	Url       string
	Created   int64
	Host      sql.NullString
	Username  sql.NullString
}

func (q *Queries) GetFile(ctx context.Context, digest string) (GetFileRow, error) {
	row := q.db.QueryRowContext(ctx, getFile, digest)
	var i GetFileRow
	err := row.Scan(
		&i.ID,
		&i.Digest,
		&i.Path,
		&i.ApID,
		&i.Name,
		&i.Filename,
		&i.Type,
		&i.MimeType,
		&i.SizeBytes,
		&i.Local,
		&i.Url,
		&i.Created,
		&i.Host,
		&i.Username,
	)
	return i, err
}

const getFollow = `-- name: GetFollow :one
SELECT follower_ap_id, followee_ap_id FROM follows WHERE follow_ap_id = ?1
`

type GetFollowRow struct {
	FollowerApID string
	FolloweeApID string
}

func (q *Queries) GetFollow(ctx context.Context, followApID sql.NullString) (GetFollowRow, error) {
	row := q.db.QueryRowContext(ctx, getFollow, followApID)
	var i GetFollowRow
	err := row.Scan(&i.FollowerApID, &i.FolloweeApID)
	return i, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT follower_ap_id FROM follows WHERE followee_ap_id = ?
`

func (q *Queries) GetFollowers(ctx context.Context, followeeApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, followeeApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var follower_ap_id string
		if err := rows.Scan(&follower_ap_id); err != nil {
			return nil, err
		}
		items = append(items, follower_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowing = `-- name: GetFollowing :many
SELECT followee_ap_id FROM follows WHERE follower_ap_id = ?
`

func (q *Queries) GetFollowing(ctx context.Context, followerApID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, followerApID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var followee_ap_id string
		if err := rows.Scan(&followee_ap_id); err != nil {
			return nil, err
		}
		items = append(items, followee_ap_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignUserData = `-- name: GetForeignUserData :one
SELECT
    u.id,
    u.username,
    u.name,
    u.host,
    u.url,
    u.local,
    u.summary
FROM users u
WHERE u.username = lower(?) AND NOT u.local AND u.host = ?
`

type GetForeignUserDataParams struct {
	LOWER string
	Host  sql.NullString
}

type GetForeignUserDataRow struct {
	ID       int64
	Username sql.NullString
	Name     sql.NullString
	Host     sql.NullString
	Url      sql.NullString
	Local    bool
	Summary  sql.NullString
}

func (q *Queries) GetForeignUserData(ctx context.Context, arg GetForeignUserDataParams) (GetForeignUserDataRow, error) {
	row := q.db.QueryRowContext(ctx, getForeignUserData, arg.LOWER, arg.Host)
	var i GetForeignUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Host,
		&i.Url,
		&i.Local,
		&i.Summary,
	)
	return i, err
}

const getInboxByActorId = `-- name: GetInboxByActorId :one
SELECT u.inbox as inbox FROM users u WHERE u.ap_id = ?1
UNION
SELECT i.inbox as inbox FROM collectives i WHERE i.url = ?1
LIMIT 1
`

func (q *Queries) GetInboxByActorId(ctx context.Context, apID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getInboxByActorId, apID)
	var inbox string
	err := row.Scan(&inbox)
	return inbox, err
}

const getInstanceId = `-- name: GetInstanceId :one
SELECT id from collectives where host = ?
`

func (q *Queries) GetInstanceId(ctx context.Context, host string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getInstanceId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPrivateKeyByID = `-- name: GetPrivateKeyByID :one
SELECT private_key FROM users WHERE local AND ap_id = ?1
UNION
SELECT private_key FROM collectives WHERE private_key IS NOT NULL AND url = ?1
LIMIT 1
`

func (q *Queries) GetPrivateKeyByID(ctx context.Context, apID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getPrivateKeyByID, apID)
	var private_key string
	err := row.Scan(&private_key)
	return private_key, err
}

const getRevisionList = `-- name: GetRevisionList :many
SELECT
    r.id,
    r.reviewed,
    r.summary,
    a.title,
    u.username,
    r.created
FROM (
    SELECT
        art.id,
        art.title
    FROM articles art
    LEFT JOIN (
        SELECT username AS name, ap_id AS id FROM users WHERE users.username = ?1
        UNION
        SELECT name AS name, url AS id FROM collectives WHERE collectives.name = ?1
    ) AS att ON att.id = art.attributed_to
    WHERE LOWER(art.title) = LOWER(?2) AND art.host = ?3
    LIMIT 1
) a
JOIN revisions r ON r.article_id = a.id
JOIN users u ON r.user_id = u.id
ORDER BY r.created DESC
`

type GetRevisionListParams struct {
	Author sql.NullString
	Title  string
	Host   sql.NullString
}

type GetRevisionListRow struct {
	ID       int64
	Reviewed bool
	Summary  sql.NullString
	Title    string
	Username sql.NullString
	Created  int64
}

func (q *Queries) GetRevisionList(ctx context.Context, arg GetRevisionListParams) ([]GetRevisionListRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionList, arg.Author, arg.Title, arg.Host)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionListRow
	for rows.Next() {
		var i GetRevisionListRow
		if err := rows.Scan(
			&i.ID,
			&i.Reviewed,
			&i.Summary,
			&i.Title,
			&i.Username,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisionsByUserId = `-- name: GetRevisionsByUserId :many
SELECT
    r.id,
    a.title,
    r.summary,
    r.reviewed,
    r.created
FROM revisions r
JOIN articles a
ON a.id = r.article_id
WHERE r.user_id = ?
`

type GetRevisionsByUserIdRow struct {
	ID       int64
	Title    string
	Summary  sql.NullString
	Reviewed bool
	Created  int64
}

func (q *Queries) GetRevisionsByUserId(ctx context.Context, userID sql.NullInt64) ([]GetRevisionsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevisionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevisionsByUserIdRow
	for rows.Next() {
		var i GetRevisionsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Reviewed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserApId = `-- name: GetUserApId :one
SELECT ap_id FROM users WHERE local AND username = lower(?1)
UNION
SELECT url AS ap_id FROM collectives WHERE name = lower(?1)
`

func (q *Queries) GetUserApId(ctx context.Context, lower string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserApId, lower)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const getUserFull = `-- name: GetUserFull :one
SELECT
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    created,
    last_updated
FROM users
WHERE local AND ap_id = ?
`

type GetUserFullRow struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	Created     int64
	LastUpdated int64
}

func (q *Queries) GetUserFull(ctx context.Context, apID string) (GetUserFullRow, error) {
	row := q.db.QueryRowContext(ctx, getUserFull, apID)
	var i GetUserFullRow
	err := row.Scan(
		&i.ApID,
		&i.Url,
		&i.Username,
		&i.Name,
		&i.Summary,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
		&i.PublicKey,
		&i.Created,
		&i.LastUpdated,
	)
	return i, err
}

const getUserFullByID = `-- name: GetUserFullByID :one
SELECT
    ap_id,
    url,
    username,
    name,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    created,
    last_updated
FROM users
WHERE id = ?
`

type GetUserFullByIDRow struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	Created     int64
	LastUpdated int64
}

func (q *Queries) GetUserFullByID(ctx context.Context, id int64) (GetUserFullByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserFullByID, id)
	var i GetUserFullByIDRow
	err := row.Scan(
		&i.ApID,
		&i.Url,
		&i.Username,
		&i.Name,
		&i.Summary,
		&i.Inbox,
		&i.Outbox,
		&i.Followers,
		&i.PublicKey,
		&i.Created,
		&i.LastUpdated,
	)
	return i, err
}

const getUserId = `-- name: GetUserId :one
SELECT id FROM users where ap_id = ? LIMIT 1
`

func (q *Queries) GetUserId(ctx context.Context, apID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserId, apID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserKeys = `-- name: GetUserKeys :one
SELECT ap_id, private_key FROM users WHERE local AND id = ?
`

type GetUserKeysRow struct {
	ApID       string
	PrivateKey string
}

func (q *Queries) GetUserKeys(ctx context.Context, id int64) (GetUserKeysRow, error) {
	row := q.db.QueryRowContext(ctx, getUserKeys, id)
	var i GetUserKeysRow
	err := row.Scan(&i.ApID, &i.PrivateKey)
	return i, err
}

const getUserUriById = `-- name: GetUserUriById :one
SELECT ap_id FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserUriById(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserUriById, id)
	var ap_id string
	err := row.Scan(&ap_id)
	return ap_id, err
}

const insertApObject = `-- name: InsertApObject :exec
INSERT INTO ap_object_cache (ap_id, local_table, local_id, type, raw_json, last_updated, last_fetched)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertApObjectParams struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastUpdated sql.NullInt64
	LastFetched sql.NullInt64
}

func (q *Queries) InsertApObject(ctx context.Context, arg InsertApObjectParams) error {
	_, err := q.db.ExecContext(ctx, insertApObject,
		arg.ApID,
		arg.LocalTable,
		arg.LocalID,
		arg.Type,
		arg.RawJson,
		arg.LastUpdated,
		arg.LastFetched,
	)
	return err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO files (
    local,
    digest,
    path,
    ap_id,
    name,
    filename,
    type,
    mime_type,
    size_bytes,
    uploaded_by,
    url
) VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertFileParams struct {
	Local      bool
	Digest     string
	Path       sql.NullString
	ApID       string
	Name       sql.NullString
	Filename   sql.NullString
	Type       string
	MimeType   string
	SizeBytes  sql.NullInt64
	UploadedBy sql.NullInt64
	Url        string
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.Local,
		arg.Digest,
		arg.Path,
		arg.ApID,
		arg.Name,
		arg.Filename,
		arg.Type,
		arg.MimeType,
		arg.SizeBytes,
		arg.UploadedBy,
		arg.Url,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertInstance = `-- name: InsertInstance :one
INSERT INTO collectives (host, public_key, inbox) VALUES (?, ?, ?) RETURNING id
`

type InsertInstanceParams struct {
	Host      string
	PublicKey sql.NullString
	Inbox     sql.NullString
}

func (q *Queries) InsertInstance(ctx context.Context, arg InsertInstanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertInstance, arg.Host, arg.PublicKey, arg.Inbox)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertOrUpdateApObject = `-- name: InsertOrUpdateApObject :exec
INSERT INTO ap_object_cache (ap_id, local_table, local_id, type, raw_json, last_fetched)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT (ap_id) DO UPDATE
SET type = ?4,
    raw_json = ?5,
    last_updated = cast(strftime('%s','now') as int),
    last_fetched = ?6
`

type InsertOrUpdateApObjectParams struct {
	ApID        string
	LocalTable  sql.NullString
	LocalID     sql.NullInt64
	Type        string
	RawJson     []byte
	LastFetched sql.NullInt64
}

func (q *Queries) InsertOrUpdateApObject(ctx context.Context, arg InsertOrUpdateApObjectParams) error {
	_, err := q.db.ExecContext(ctx, insertOrUpdateApObject,
		arg.ApID,
		arg.LocalTable,
		arg.LocalID,
		arg.Type,
		arg.RawJson,
		arg.LastFetched,
	)
	return err
}

const insertOrUpdateUser = `-- name: InsertOrUpdateUser :one
INSERT INTO users (
    local,
    ap_id,
    url,
    username,
    name,
    host,
    summary,
    inbox,
    outbox,
    followers,
    public_key,
    trusted,
    last_updated,
    last_fetched
) VALUES (false, ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, false, (cast(strftime('%s','now') as int)), ?11)
ON CONFLICT (ap_id) DO UPDATE
SET url = ?2,
    username = ?3,
    name = ?4,
    summary = ?5,
    inbox = ?6,
    outbox = ?7,
    followers = ?8,
    public_key = ?9,
    last_updated = cast(strftime('%s','now') as int),
    last_fetched = ?10
RETURNING id
`

type InsertOrUpdateUserParams struct {
	ApID        string
	Url         sql.NullString
	Username    sql.NullString
	Name        sql.NullString
	Host        sql.NullString
	Summary     sql.NullString
	Inbox       string
	Outbox      string
	Followers   string
	PublicKey   string
	LastFetched sql.NullInt64
}

func (q *Queries) InsertOrUpdateUser(ctx context.Context, arg InsertOrUpdateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertOrUpdateUser,
		arg.ApID,
		arg.Url,
		arg.Username,
		arg.Name,
		arg.Host,
		arg.Summary,
		arg.Inbox,
		arg.Outbox,
		arg.Followers,
		arg.PublicKey,
		arg.LastFetched,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertRevision = `-- name: InsertRevision :one
INSERT INTO revisions (
    ap_id,
    article_id,
    user_id,
    summary,
    diff,
    published,
    prev
) VALUES (?1, ?2, ?3, ?4, ?5, true, ?6)
RETURNING id
`

type InsertRevisionParams struct {
	ApID      sql.NullString
	ArticleID int64
	UserID    sql.NullInt64
	Summary   sql.NullString
	Diff      string
	Prev      sql.NullInt64
}

func (q *Queries) InsertRevision(ctx context.Context, arg InsertRevisionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertRevision,
		arg.ApID,
		arg.ArticleID,
		arg.UserID,
		arg.Summary,
		arg.Diff,
		arg.Prev,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isAdmin = `-- name: IsAdmin :one
SELECT admin FROM accounts a WHERE a.id = ?
`

func (q *Queries) IsAdmin(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isAdmin, id)
	var admin bool
	err := row.Scan(&admin)
	return admin, err
}

const isUserTrusted = `-- name: IsUserTrusted :one
SELECT trusted FROM users where id = ?1 LIMIT 1
`

func (q *Queries) IsUserTrusted(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserTrusted, id)
	var trusted bool
	err := row.Scan(&trusted)
	return trusted, err
}

const outboxForInbox = `-- name: OutboxForInbox :one
SELECT outbox from users where inbox = ?
`

func (q *Queries) OutboxForInbox(ctx context.Context, inbox string) (string, error) {
	row := q.db.QueryRowContext(ctx, outboxForInbox, inbox)
	var outbox string
	err := row.Scan(&outbox)
	return outbox, err
}

const updateAp = `-- name: UpdateAp :exec
UPDATE ap_object_cache
SET
    raw_json = ?,
    last_updated = (cast(strftime('%s','now') as int))
WHERE ap_id = ?
`

type UpdateApParams struct {
	RawJson []byte
	ApID    string
}

func (q *Queries) UpdateAp(ctx context.Context, arg UpdateApParams) error {
	_, err := q.db.ExecContext(ctx, updateAp, arg.RawJson, arg.ApID)
	return err
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE articles
SET
    content = ?1,
    last_updated = (cast(strftime('%s','now') as int))
WHERE id = ?2
`

type UpdateArticleParams struct {
	Content string
	ID      int64
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle, arg.Content, arg.ID)
	return err
}

const updateArticleByIRI = `-- name: UpdateArticleByIRI :exec
UPDATE articles
SET
    content = ?,
    last_updated = (cast(strftime('%s','now') as int))
WHERE ap_id = ?
`

type UpdateArticleByIRIParams struct {
	Content string
	ApID    string
}

func (q *Queries) UpdateArticleByIRI(ctx context.Context, arg UpdateArticleByIRIParams) error {
	_, err := q.db.ExecContext(ctx, updateArticleByIRI, arg.Content, arg.ApID)
	return err
}

const updateFollowApId = `-- name: UpdateFollowApId :exec
UPDATE follows
SET follow_ap_id = ?
WHERE id = ?
`

type UpdateFollowApIdParams struct {
	FollowApID sql.NullString
	ID         int64
}

func (q *Queries) UpdateFollowApId(ctx context.Context, arg UpdateFollowApIdParams) error {
	_, err := q.db.ExecContext(ctx, updateFollowApId, arg.FollowApID, arg.ID)
	return err
}

const updateFollowInbox = `-- name: UpdateFollowInbox :exec
UPDATE follows SET follower_inbox_url = ? WHERE follower_ap_id = ?
`

type UpdateFollowInboxParams struct {
	FollowerInboxUrl sql.NullString
	FollowerApID     string
}

func (q *Queries) UpdateFollowInbox(ctx context.Context, arg UpdateFollowInboxParams) error {
	_, err := q.db.ExecContext(ctx, updateFollowInbox, arg.FollowerInboxUrl, arg.FollowerApID)
	return err
}

const updateRevisionApId = `-- name: UpdateRevisionApId :exec
UPDATE revisions SET ap_id = ? WHERE id = ?
`

type UpdateRevisionApIdParams struct {
	ApID sql.NullString
	ID   int64
}

func (q *Queries) UpdateRevisionApId(ctx context.Context, arg UpdateRevisionApIdParams) error {
	_, err := q.db.ExecContext(ctx, updateRevisionApId, arg.ApID, arg.ID)
	return err
}

const userExists = `-- name: UserExists :one
SELECT COUNT(id) == 1 FROM users WHERE ap_id = ?
`

func (q *Queries) UserExists(ctx context.Context, apID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, apID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
